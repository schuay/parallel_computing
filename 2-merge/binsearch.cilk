#include "merge.h"

#include <cilk-lib.cilkh>

/* #define DEBUG(...) fprintf(stderr, __VA_ARGS__) */
#define DEBUG(...)

const char *algorithm_name = "binary search based parallel merge";

static size_t binary_search(TYPE needle, const TYPE *haystack, size_t n)
{
    size_t low = 0;
    size_t high = n;

    while (low < high) {
        size_t mid = (low + high) / 2;
        if (needle < haystack[mid]) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }

    return low;
}

struct bsearch_args_t {
    size_t *rankA;
    size_t *rankB;
    const TYPE *a;
    size_t n;
    const TYPE *b;
    size_t m;
    size_t p;
};

static void binary_search_datapara(size_t i, void *args)
{
    struct bsearch_args_t *bargs = (struct bsearch_args_t *) args;

    const TYPE *a = bargs->a;
    size_t n = bargs->n;
    const TYPE *b = bargs->b;
    size_t m = bargs->m;
    size_t p = bargs->p;

    TYPE needleA = a[i * n / p];
    TYPE needleB = b[i * m / p];

    bargs->rankA[i] = binary_search(needleA, b, m);
    bargs->rankB[i] = binary_search(needleB, a, n);
}

cilk void datapara(size_t i, size_t j, size_t unit, void (*f)(size_t, void*), void *optargs)
{
    if (j - i <= unit) {
        size_t k;
        for (k = i; k < j; k++) {
            f(k, optargs);
        }
    } else {
        size_t m = (i + j) / 2;
        spawn datapara(i, m, unit, f, optargs);
        spawn datapara(m, j, unit, f, optargs);
        sync;
    }
}

struct merge_args_t {
    const size_t *rankA;
    const size_t *rankB;
    const TYPE *a;
    size_t n;
    const TYPE *b;
    size_t m;
    size_t p;
    TYPE *c;
};

static void merge_datapara(size_t i, void *args)
{
    struct merge_args_t *margs = (struct merge_args_t *) args;

    const size_t *rankA = margs->rankA;
    const size_t *rankB = margs->rankB;
    const TYPE *a = margs->a;
    size_t n = margs->n;
    const TYPE *b = margs->b;
    size_t m = margs->m;
    size_t p = margs->p;
    TYPE *c = margs->c;

    size_t a_start = (i == 0) ? 0 : rankB[i];
    size_t a_length = (i == p - 1) ? n - a_start : rankB[i + 1] - a_start;

    size_t b_start = (i == 0) ? 0 : rankA[i];
    size_t b_length = (i == p - 1) ? m - b_start : rankA[i + 1] - b_start;

    merge_seq(a + a_start, a_length, b + b_start, b_length, c + a_start + b_start);
}

cilk void merge_impl(const TYPE *a, size_t n, const TYPE *b, size_t m, TYPE *c,
        perf_t *perf, int *nproc)
{
    size_t p = Cilk_active_size;
    size_t *rankA = calloc(p, sizeof(size_t));
    size_t *rankB = calloc(p, sizeof(size_t));

    struct bsearch_args_t bsearch_args = { rankA, rankB, a, n, b, m, p };
    struct merge_args_t merge_args = { rankA, rankB, a, n, b, m, p, c };

    *nproc = p;

    spawn datapara(0, p, 1, binary_search_datapara, &bsearch_args);
    sync;

    spawn datapara(0, p, 1, merge_datapara, &merge_args);
    sync;
}
